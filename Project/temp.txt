import javax.swing.*;
import javax.swing.border.LineBorder;

import java.awt.*;
import java.awt.event.*;
import java.util.Calendar;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.util.Scanner;


public class GameInterface {
	static JFrame frame;
	static Container pane;
	//The boxes themselves
	static JButton[][] box;
	//The smaller boxes which can be used to store possible numbers
	static JButton btnInputMode;
	static JLabel lblInputLabel;
	static JButton btnQuit;
	static JButton btnHint;
	static JLabel elapseTimer;
	static JLabel timerLabel;
	//static Square[][] entry;
	
	
	static final int boxWidth = 50;
	static final int boxHeight = 50;
	//static final int subBoxHeight = 20;
	//static final int subBoxWidth = 50;
	static final int frameWidth = 600;
	static final int frameHeight = 600;
	
	public GameInterface(Square[][] newLayout){
		boardLayout = newLayout;
		
		frame = new JFrame("Sudoku");
		frame.setSize(frameWidth, frameHeight);
		pane = frame.getContentPane();
		
		pane.setLayout(null);
		
		box = new JButton[9][9];
		//Get it so that I take this from the puzzle
		//entry = new Square[9][9];
		//subBox = new JTextPane[9][9];
		setStartingBoxInfo();
		
		timerLabel = new JLabel("Elapsed Time");
		pane.add(timerLabel);
		timerLabel.setBounds(20, frameHeight - 120, timerLabel.getPreferredSize().width, timerLabel.getPreferredSize().height);
		
		elapseTimer = new JLabel("00:00");
		pane.add(elapseTimer);
		elapseTimer.setBounds(30, frameHeight - 100, elapseTimer.getPreferredSize().width + 100, elapseTimer.getPreferredSize().height);
		
		btnInputMode = new JButton("Entry Mode");
		lblInputLabel = new JLabel("Current Writing Mode Click or hold Shift to change");
		pane.add(btnInputMode);
		pane.add(lblInputLabel);	
		btnInputMode.setBounds(10, frameHeight - 60, btnInputMode.getPreferredSize().width + 50, btnInputMode.getPreferredSize().height);
		lblInputLabel.setBounds(10, frameHeight - 80, lblInputLabel.getPreferredSize().width, lblInputLabel.getPreferredSize().height);
		btnInputMode.addActionListener(new btnInputModeListener());
		
		btnHint = new JButton("HINT");
		pane.add(btnHint);
		btnHint.setBounds(360, frameHeight - 60, btnHint.getPreferredSize().width + 50, btnInputMode.getPreferredSize().height);
		btnHint.addActionListener(new btnHintListener());
		
		btnQuit = new JButton("QUIT");
		pane.add(btnQuit);
		btnQuit.setBounds(200, frameHeight - 60, btnQuit.getPreferredSize().width + 50, btnInputMode.getPreferredSize().height);
		btnQuit.addActionListener(new btnQuitListener());

		//frame.addKeyListener(new keyPressedListener());
		frame.requestFocus();
		frame.setVisible(true);
		updateTimer();
	}
		
	/**
	 * Returns the integer of the given square or -1 if the square is empty
	 * @param row	The row value of the square (0-8)
	 * @param col	The column value of the square (0-8)
	 * @return		The integer of the square
	 */
	public int getBoxValue(int row, int col){
		return boardLayout[row][col].getCurrentValue();
	}
	
	/**
	 * Checks if the player has won the game. This checks
	 * if the boards if completely filled first, then for each filled
	 * squares, checks if there are duplicates in the regions.
	 * @return True if the board is completely filled and all values
	 * are valid. False otherwise.
	 */
	public boolean hasWon() {
		boolean boardFilled = false;
		for (int i = 0; i < Puzzle.ROW_NUMBER; i++) {
			for (int j = 0; j < Puzzle.COLUMN_NUMBER; j++) {
				if (boardLayout[i][j].getCurrentValue() != 0) {
					boardFilled = true;
				} else {
					boardFilled = false;
					break;
				}
			}
		}
		
		if (boardFilled) {
			for (int i = 0; i < Puzzle.ROW_NUMBER; i++) {
				for (int j = 0; j < Puzzle.COLUMN_NUMBER; j++) {
					if (!LegalCheck.checkLegal(boardLayout, boardLayout[i][0], boardLayout[i][0].getCurrentValue()))
						return false;
				}
			}
		} else
			return false;
		return true;
	}
	
	public void updateTimer() {
		int hour, minute, sec;
		String label = "";
		while (!hasWon()) {
			long timeInSeconds = Puzzle.calculateTimeElapse(startTime);
			hour = (int) (timeInSeconds / 3600);
			timeInSeconds = timeInSeconds - (hour * 3600);
			minute = (int) (timeInSeconds / 60);
			timeInSeconds = timeInSeconds - (minute * 60);
			sec = (int) (timeInSeconds);
			elapseTimer.setText(String.format("%02d", hour) + ":" + String.format("%02d", minute)  + 
					":" + String.format("%02d", sec));
		}
	}
	
	//TODO Input to set the setting of the boxes (E.g. red "MISTAKE" color)
	/**
	 * De-selects all squares
	 */
	public static void deselectAll(){
		inputX = -1;
		inputY = -1;
		source = null;
	}
	
	/**
	 * Returns whether or not there is a selected square
	 * @return	True if a square is selected, false otherwise
	 */
	public boolean squareSelected(){
		return (source != null);
	}

	
	private static void setStartingBoxInfo(){
		int x = 0;
		int y = 0;
		Integer value;
		Color gray = new Color(232, 232, 232);
		while (y < 9){
			while (x < 9){
				box[x][y] = new JButton();
				//subBox[x][y] = new JTextPane();
				pane.add(box[x][y]);
				//pane.add(subBox[x][y]);
				box[x][y].setBounds(x*boxWidth+10, y*boxHeight+10, boxWidth, boxHeight);
				box[x][y].addActionListener(new btnSquareListener(x, y));
				box[x][y].addKeyListener(new keyPressedListener(y, x));
				value = boardLayout[y][x].getCurrentValue();
				box[x][y].setBackground(Color.white);
				if (value != 0){
					box[x][y].setText(value.toString());
					if (boardLayout[y][x].getType() == Square.PREDEFINE_CELL) {
						box[x][y].setBackground(gray);
					}
				}
				//box[x][y].setForeground(defaultBGColor);
				//subBox[x][y].setBounds(x*boxWidth+10, y*boxHeight+10, boxWidth, boxHeight);
				//subBox[x][y].setEnabled(false);
				//entry[x][y] = new Square(0, 0);
				x++;
			}
			y++;
			x = 0;
		}
	}
	
	private static void resetSourceBox(){
		System.out.println("STUFF");
		//If there is a set value for the square, set it to that
		if (boardLayout[inputY][inputX].getCurrentValue() > 0){
			source.setText(Integer.toString(boardLayout[inputY][inputX].getCurrentValue()));
		} else {
			Square tempDraft = boardLayout[inputY][inputX];
			Integer x = 0;
			String boxString = "";
			while (x < 9){
				if (tempDraft.isMarkedDraft(x)){
					boxString = (boxString + " " + x.toString());
				}
				x++;
			}
			source.setText(boxString);
		}
		pane.repaint();

	}
		
	private static boolean draftEntry = false;
	private static JButton source;
	private static int inputX;
	private static int inputY;
	private static Square[][] boardLayout;
	private static Calendar startTime = Calendar.getInstance();
	
	//============================================================================================================================================================
	//AAAAAAAA  CCCCCCCC  TTTTTTTTTT  IIIIII  OOOOOOOO  NN      NN        LL      IIIIII  SSSSSSSS  TTTTTTTTTT  EEEEEEEE  NN      NN  EEEEEEEE  RRRRRR    SSSSSSSS
	//AA    AA  CC            TT        II    OO    OO  NNNN    NN        LL        II    SS            TT      EE        NNNN    NN  EE        RR    RR  SS
	//AA    AA  CC            TT        II    OO    OO  NN  NN  NN        LL        II    SSSS          TT      EEEEEE    NN  NN  NN  EEEEEE    RRRRRR    SSSS
	//AAAAAAAA  CC            TT        II    OO    OO  NN  NN  NN        LL        II        SSSS      TT      EE        NN  NN  NN  EE        RRRR          SSSS
	//AA    AA  CC            TT        II    OO    OO  NN    NNNN        LL        II          SS      TT      EE        NN    NNNN  EE        RR  RR          SS
	//AA    AA  CCCCCCCC      TT      IIIIII  OOOOOOOO  NN      NN        LLLLLL  IIIIII  SSSSSSSS      TT      EEEEEEEE  NN      NN  EEEEEEEE  RR    RR  SSSSSSSS
	//============================================================================================================================================================
	
	/**
	 * Action Listener to change the input mode
	 * @author Sam
	 */
	public static class btnInputModeListener implements ActionListener{

		public void actionPerformed(ActionEvent e) {
			if (draftEntry == true){
				btnInputMode.setText("Entry Mode");
				draftEntry = false;
				deselectAll();
				//switchEntryMode();
			} else {
				btnInputMode.setText("Draft Notes Mode");
				draftEntry = true;
				deselectAll();
				//switchEntryMode();
			}
		}
		
	}
	
	/**
	 * Action Listener to quit
	 * @author Sam
	 */
	public static class btnQuitListener implements ActionListener{
		public void actionPerformed(ActionEvent e){
			System.exit(0);
		}
	}
	
	/**
	 * 
	 */
	public static class btnHintListener implements ActionListener{
		public void actionPerformed(ActionEvent e){
			HintSystem h = new HintSystem();
			Move newMove = h.Hint(boardLayout);
			if (newMove.getValue() != 0) {
				boardLayout[newMove.getY()][newMove.getX()].setCurrentValue(newMove.getValue());
				System.out.println("board val is " + boardLayout[newMove.getX()][newMove.getY()].getCurrentValue());
				inputX = newMove.getX();
				inputY = newMove.getY();
				source = box[inputX][inputY];
				Color hintColor = new Color(102, 255, 178);
				source.setForeground(hintColor);
				//source.setBackground(new Color(255,255,255));
				resetSourceBox();
			}
		}
	}
	
	/**
	 * Action Listener for each of the 81 squares 
	 * @author Sam
	 */
	public static class btnSquareListener implements ActionListener{
		int squareX, squareY;
		Color smokeWhite = new Color(245, 245, 245);
		
		public btnSquareListener(int x, int y){
			squareX = x;
			squareY = y;
		}
		
		public void actionPerformed(ActionEvent e){
			//source.setForeground(defaultBGColor);
			if (source != null) {
				source.setBorder(UIManager.getBorder("Button.border"));
//				source.setBackground(Color.WHITE);
			}
			
			System.out.println("square selected " + squareX + " " + squareY);
			System.out.println(" square type is " + boardLayout[squareY][squareX].getType() + " and has value " + boardLayout[squareY][squareX].getCurrentValue());
			source = (JButton) e.getSource();
			source.setBorder(new LineBorder(Color.BLACK));
//			source.setBackground(smokeWhite);
			inputX = squareX;
			inputY = squareY;
			//source.setText(inputX + " " + inputY);
		}
	}
	
	/**
	 * Key Press listeners for typing
	 * @author Sam
	 */
	public static class keyPressedListener implements KeyListener{
		private int row;
		private int column;
		
		
		public keyPressedListener(int row, int col){
			this.row = row;
			this.column = col;
		}
		
		public void keyPressed(KeyEvent e) {}

		public void keyReleased(KeyEvent e) {}

		//When a key is typed
		public void keyTyped(KeyEvent e) {
			System.out.println("Key Typed " + e.getKeyChar());
			char key = e.getKeyChar();
			//if the square selected isn't a predefined cell
			if (boardLayout[row][column].getType() != Square.PREDEFINE_CELL && Character.isDigit(key)){
				int number = 0;
				boolean shift = false;
				// If shift is pressed, set shift to true
				if (e.isShiftDown()){
					shift = true;
					System.out.println("SHIFT");
				}
				// then work out what number is pressed
				if (key == '!' || key == '1'){
					number = 1;
				} else if (key == '@' || key == '2'){
					number = 2;
				} else if (key == '#' || key == '3'){
					number = 3;
				} else if (key == '$' || key == '4'){
					number = 4;
				} else if (key == '%' || key == '5'){
					number = 5;
				} else if (key == '^' || key == '6'){
					number = 6;
				} else if (key == '&' || key == '7'){
					number = 7;
				} else if (key == '*' || key == '8'){
					number = 8;
				} else if (key == '(' || key == '9'){
					number = 9;
				}
				if (shift){
					boardLayout[row][column].switchDraftValue(number);
				} else {
					boardLayout[row][column].setCurrentValue(number);
				}
				resetSourceBox();
			} else if (boardLayout[row][column].getType() != Square.PREDEFINE_CELL && (e.getKeyCode() == KeyEvent.VK_BACK_SPACE || e.getKeyCode() == KeyEvent.VK_DELETE)) {
				
			}
			

			
		}
		
	}
		
	//NOTE: if you're looking for private variables, they're above the Action Listeners
}



import java.util.Calendar;
import java.util.Date;
import java.util.Random;

/**
 * A class that generates the Sudoku puzzle
 * according the level specified.
 * The board generation code was greatly insight from
 * http://www.codeproject.com/Articles/23206/Sudoku-Algorithm-Generates-a-Valid-Sudoku-in-0-018
 * @author tsph001 - Sandy Phan
 *
 */
public class Puzzle {
	
	/**
	 * Create a new Sudoku puzzle with the
	 * specified difficulty level.
	 * @param dl The difficulty level
	 * partitioned into Easy, Medium and Hard.
	 * @return Returns the 2D array of the puzzle.
	 */
	public static Square[][] createPuzzle(int dl) {
		difficultyLevel = dl;
		initialisePuzzle();
		generatePuzzle();
		printPuzzle();
		Calendar start = Calendar.getInstance();
		calculateTimeElapse(start);
		return puzzle;
	}
	
	/**
	 * Generate the whole puzzle with appropriate
	 * cells removed according to the difficulty
	 * level specified.
	 */
	private static void generatePuzzle() {
		Random rand = new Random();
		boolean conflict = false;
		int k = 0;
		int duplicateFound = 0;
		
		// Loop through the board and assign numbers to the squares
		for (int i = 0; i < ROW_NUMBER; i++) {
			for (int j = 0; j < COLUMN_NUMBER; j++) {
				
				duplicateFound = 0;
				
				// This is when backtracking a square, and that square 
				if (puzzle[i][j].getAvailableValues().size() == 0) {
					puzzle[i][j].resetTrackingValues();
					puzzle[i][j].setCurrentValue(0);
					if (j > 1)
						j = j - 2;
					else {
						j = COLUMN_NUMBER - 2;
						i--;
					}
					continue;
				}
				
				try {
					k = rand.nextInt(puzzle[i][j].getAvailableValues().size());
					while (LegalCheck.checkLegal(puzzle, puzzle[i][j], puzzle[i][j].getAvailableValues().get(k))) {
						duplicateFound++;
						puzzle[i][j].getUsedValues().add(puzzle[i][j].getAvailableValues().get(k));
						puzzle[i][j].getAvailableValues().remove(k);
						if (puzzle[i][j].getAvailableValues().size() == 0) {
							puzzle[i][j].resetTrackingValues();
							puzzle[i][j].setCurrentValue(0);
							if (j > 1)
								j = j - 2;
							else {
								j = COLUMN_NUMBER - 2;
								i--;
							}
							conflict = true;
							break;
						} else {
							conflict = false;
						}
							
						k = rand.nextInt(puzzle[i][j].getAvailableValues().size());					
					}
					if (duplicateFound == 0) {
						conflict = false;
					}
						
				} catch (IllegalArgumentException e) {
					System.out.println("Size was: "+ puzzle[i][j].getAvailableValues().size());
				}
				
				
				if (!conflict) {
					puzzle[i][j].setCurrentValue(puzzle[i][j].getAvailableValues().get(k));
					puzzle[i][j].getUsedValues().add(puzzle[i][j].getAvailableValues().get(k));
					puzzle[i][j].getAvailableValues().remove(k);
					puzzle[i][j].setType(Square.PREDEFINE_CELL);
//					System.out.println("Cell[" + i + "][" + j + "]: " + puzzle[i][j].getCurrentValue());
				}
				
			}
//			System.out.println();
		}
		removeCells();
	}
	
	/**
	 * Initialize the puzzle by setting
	 * the values of the rows, columns
	 * and 3x3 box a square should be in.
	 */
	private static void initialisePuzzle() {
		// iterate through the grids/squares.
		for (int i = 0; i < ROW_NUMBER; i++) {
			for (int j = 0; j < COLUMN_NUMBER; j++) {
				if (i <= 2) {
					if (j <= 2) {
						puzzle[i][j] = new Square(boxNum[0], Square.EMPTY_CELL);
					} else if (j > 2 && j <= 5) {
						puzzle[i][j] = new Square(boxNum[1], Square.EMPTY_CELL);
					} else if (j > 5 && j <= 8) {
						puzzle[i][j] = new Square(boxNum[2], Square.EMPTY_CELL);
					}
				} else if (i > 2 && i <= 5) {
					if (j <= 2) {
						puzzle[i][j] = new Square(boxNum[3], Square.EMPTY_CELL);
					} else if (j > 2 && j <= 5) {
						puzzle[i][j] = new Square(boxNum[4], Square.EMPTY_CELL);
					} else if (j > 5 && j <= 8) {
						puzzle[i][j] = new Square(boxNum[5], Square.EMPTY_CELL);
					}
				} else if (i > 5 && i <= 8) {
					if (j <= 2) {
						puzzle[i][j] = new Square(boxNum[6], Square.EMPTY_CELL);
					} else if (j > 2 && j <= 5) {
						puzzle[i][j] = new Square(boxNum[7], Square.EMPTY_CELL);
					} else if (j > 5 && j <= 8) {
						puzzle[i][j] = new Square(boxNum[8], Square.EMPTY_CELL);
					}
				}
				puzzle[i][j].setColumn(j);
				puzzle[i][j].setRow(i);
			}
		}
	}
	
	public static void printPuzzle() {
		for (int i = 0; i < ROW_NUMBER; i++) {
			for (int j = 0; j < COLUMN_NUMBER; j++) {
				if (puzzle[i][j].getCurrentValue() == 0) {
					System.out.print("  ");
				} else
					System.out.print(puzzle[i][j].getCurrentValue() + " ");
			}
			System.out.println();
		}
	}
	
	/**
	 * Remove the number of cells according
	 * to the difficulty level set from the
	 * constructor.
	 */
	private static void removeCells() {
		Random rand = new Random();
		int removeNum = 0;
		int min = 0, max = 0;
		if (difficultyLevel == EASY) {
			max = 49;
			min = 44;
		} else if (difficultyLevel == MEDIUM) {
			max = 56;
			min = 50;
			
		} else if (difficultyLevel == HARD) {
			max = 64;
			min = 57; 
		}
		
		removeNum = min + (int)(Math.random() * ((max - min) + 1));
		
		for (int i = 0; i < removeNum; i++) {
			int j = rand.nextInt(ROW_NUMBER);
			int k = rand.nextInt(COLUMN_NUMBER);
			if (puzzle[j][k].getCurrentValue() == 0 && 
					puzzle[j][k].getType() == Square.EMPTY_CELL) {
				i--;
				continue;
			}
			puzzle[j][k].setCurrentValue(INITIAL_VALUE);
			puzzle[j][k].setType(Square.USER_INPUT_CELL);
			puzzle[j][k].resetTrackingValues();
		}
	}
	
	public static long calculateTimeElapse(Calendar startTime) {
		Calendar endTime = Calendar.getInstance();
		Date st = startTime.getTime();
		Date et = endTime.getTime();
		long ls = st.getTime();
		long le = et.getTime();
		long diff = (le - ls) / 1000;
		return diff;
	}
	
	// levels of difficulty (not sure where to place them yet).
	// Should this be placed in the main function or should this be
	// placed in any classes that have a difficulty defined.
	public static final int EASY = 0;
	public static final int MEDIUM = 1;
	public static final int HARD = 2;
	public static final int ROW_NUMBER = 9;
	public static final int COLUMN_NUMBER = 9;
	private static final int INITIAL_VALUE = 0;
	private static int difficultyLevel;
	
	// An array of the index of the 3x3 boxes.
	// An array of the position index of the 3x3 boxes in the following format.
	//  0 1 2
	//  3 4 5
	//  6 7 8
	// These should be a constant, as it will not be modified.
	private static final int[] boxNum = {0, 1, 2, 3, 4, 5, 6, 7, 8};
	private static Square puzzle[][] = new Square[ROW_NUMBER][COLUMN_NUMBER];
}
